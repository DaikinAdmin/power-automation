import { BulkUploadItem, Item, UploadType } from '../types/item';
import { db } from '@/db';
import { category, subcategories, brand, warehouse, item, itemDetails, itemPrice } from '@/db/schema';
import { eq } from 'drizzle-orm';

type Badge = 'NEW_ARRIVALS' | 'BESTSELLER' | 'HOT_DEALS' | 'LIMITED_EDITION' | 'ABSENT';

export async function convertUploadTypeToItems(uploadData: UploadType[]): Promise<BulkUploadItem[]> {
  const items: Item[] = [];
  // Group upload data by articleId to handle multiple warehouse entries
  const groupedByArticle = groupByArticleId(uploadData);

  for (const [articleId, uploads] of groupedByArticle.entries()) {
    const firstUpload = uploads[0];

    // Find or create category and subcategory
    const { category, subCategory } = await findOrCreateCategoryAndSubCategory(
      firstUpload.categoryName,
      firstUpload.subCategoryName
    );

    // Find or create brand
    const brand = await findOrCreateBrand(firstUpload.brandName);

    // Create item details
    const itemDetails = uploads.map(upload => ({
      id: '', // Will be generated by Prisma
      itemId: '', // Will be set when item is created
      locale: upload.locale,
      description: upload.description,
      specifications: upload.specifications || null,
      itemName: upload.itemName,
      seller: upload.seller || null,
      discount: upload.discount || null,
      popularity: upload.popularity || null,
    }));

    // Create item prices with warehouses
    const itemPrices = [];
    for (const upload of uploads) {
      const warehouse = await findOrCreateWarehouse(upload.warehouseName);

      itemPrices.push({
        id: '', // Will be generated by Prisma
        itemId: '', // Will be set when item is created
        warehouseId: warehouse.id,
        price: upload.price,
        quantity: upload.quantity,
        promotionPrice: upload.promotionPrice || null,
        promoCode: upload.promoCode || null,
        promoEndDate: upload.promoEndDate ? new Date(upload.promoEndDate) : null,
        badge: mapBadge(upload.badge),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        warehouse,
        history: []
      });
    }

    // Build the complete Item object
    const item: BulkUploadItem = {
      id: '', // Will be generated by database
      articleId: firstUpload.articleId,
      slug: generateSlug(firstUpload.articleId),
      isDisplayed: firstUpload.isDisplayed,
      sellCounter: firstUpload.sellCounter || 0,
      itemImageLink: firstUpload.itemImageLink || null,
      categorySlug: subCategory?.slug || category.slug,
      brandSlug: brand?.alias || null,
      brandName: brand?.name || null,
      warrantyType: firstUpload.warrantyType || null,
      warrantyLength: firstUpload.warrantyLength || null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      item_details: itemDetails[0],
      item_price: itemPrices[0],
      category: {
        ...category,
        subCategories: subCategory ? [subCategory] : []
      },
      brand
    };
    items.push(item);
  }
  // console.log("Converted items: ", items);
  return items;
}

function groupByArticleId(uploadData: UploadType[]): Map<string, UploadType[]> {
  console.log("uploadData: ", uploadData);
  const grouped = new Map<string, UploadType[]>();

  for (const upload of uploadData) {
    if (!grouped.has(upload.articleId)) {
      grouped.set(upload.articleId, []);
    }
    grouped.get(upload.articleId)!.push(upload);
  }

  return grouped;
}

async function findOrCreateCategoryAndSubCategory(categoryName: string, subCategoryName: string) {
  // Find or create category
  let [categoryData] = await db
    .select()
    .from(category)
    .where(eq(category.name, categoryName))
    .limit(1);

  if (!categoryData) {
    const now = new Date().toISOString();
    [categoryData] = await db
      .insert(category)
      .values({
        id: generateSlug(categoryName),
        name: categoryName,
        slug: generateSlug(categoryName),
        isVisible: true,
        createdAt: now,
        updatedAt: now
      })
      .returning();
  }

  // Find subcategory if provided
  let subCategoryData = null;
  if (subCategoryName && subCategoryName.trim() !== '') {
    [subCategoryData] = await db
      .select()
      .from(subcategories)
      .where(eq(subcategories.name, subCategoryName))
      .limit(1);

    if (!subCategoryData) {
      const now = new Date().toISOString();
      [subCategoryData] = await db
        .insert(subcategories)
        .values({
          id: generateSlug(subCategoryName),
          name: subCategoryName,
          slug: generateSlug(subCategoryName),
          categorySlug: categoryData.slug,
          isVisible: true,
          createdAt: now,
          updatedAt: now
        })
        .returning();
    }
  }

  return { category: categoryData, subCategory: subCategoryData };
}

async function findOrCreateBrand(brandName: string) {
  if (!brandName) return null;

  let [brandData] = await db
    .select()
    .from(brand)
    .where(eq(brand.name, brandName))
    .limit(1);

  if (!brandData) {
    const now = new Date().toISOString();
    [brandData] = await db
      .insert(brand)
      .values({
        id: generateSlug(brandName),
        name: brandName,
        alias: generateSlug(brandName),
        imageLink: '', // Default empty, can be updated later
        isVisible: true,
        createdAt: now,
        updatedAt: now
      })
      .returning();
  }

  return brandData;
}

async function findOrCreateWarehouse(warehouseName: string) {
  let [warehouseData] = await db
    .select()
    .from(warehouse)
    .where(eq(warehouse.name, warehouseName))
    .limit(1);

  if (!warehouseData) {
    const now = new Date().toISOString();
    const { nanoid } = await import('nanoid');
    [warehouseData] = await db
      .insert(warehouse)
      .values({
        id: nanoid(),
        name: warehouseName,
        displayedName: warehouseName,
        countrySlug: 'other',
        isVisible: true,
        createdAt: now,
        updatedAt: now
      })
      .returning();
  }

  return warehouseData;
}

function generateSlug(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function mapBadge(badgeString: string): Badge {
  const badgeMap: Record<string, Badge> = {
    'NEW_ARRIVALS': 'NEW_ARRIVALS',
    'BESTSELLER': 'BESTSELLER',
    'HOT_DEALS': 'HOT_DEALS',
    'LIMITED_EDITION': 'LIMITED_EDITION',
    'ABSENT': 'ABSENT'
  };

  return badgeMap[badgeString?.toUpperCase()] || 'ABSENT';
}
