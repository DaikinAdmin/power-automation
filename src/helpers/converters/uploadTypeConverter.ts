import { Badge } from '@prisma/client';
import { BulkUploadItem, Item, UploadType } from '../types/item';
import prisma from '@/db';

export async function convertUploadTypeToItems(uploadData: UploadType[]): Promise<BulkUploadItem[]> {
  const items: Item[] = [];
  // Group upload data by articleId to handle multiple warehouse entries
  const groupedByArticle = groupByArticleId(uploadData);

  for (const [articleId, uploads] of groupedByArticle.entries()) {
    const firstUpload = uploads[0];

    // Find or create category and subcategory
    const { category, subCategory } = await findOrCreateCategoryAndSubCategory(
      firstUpload.categoryName,
      firstUpload.subCategoryName
    );

    // Find or create brand
    const brand = await findOrCreateBrand(firstUpload.brandName);

    // Create item details
    const itemDetails = uploads.map(upload => ({
      id: '', // Will be generated by Prisma
      itemId: '', // Will be set when item is created
      locale: upload.locale,
      description: upload.description,
      specifications: upload.specifications || null,
      itemName: upload.itemName,
      seller: upload.seller || null,
      discount: upload.discount || null,
      popularity: upload.popularity || null,
    }));

    // Create item prices with warehouses
    const itemPrices = [];
    for (const upload of uploads) {
      const warehouse = await findOrCreateWarehouse(upload.warehouseName);

      itemPrices.push({
        id: '', // Will be generated by Prisma
        itemId: '', // Will be set when item is created
        warehouseId: warehouse.id,
        price: upload.price,
        quantity: upload.quantity,
        promotionPrice: upload.promotionPrice || null,
        promoCode: upload.promoCode || null,
        promoEndDate: upload.promoEndDate ? new Date(upload.promoEndDate) : null,
        badge: mapBadge(upload.badge),
        createdAt: new Date(),
        updatedAt: new Date(),
        warehouse,
        history: []
      });
    }

    // Build the complete Item object
    const item: BulkUploadItem = {
      id: '', // Will be generated by Prisma
      articleId: firstUpload.articleId,
      isDisplayed: firstUpload.isDisplayed,
      sellCounter: firstUpload.sellCounter || 0,
      itemImageLink: firstUpload.itemImageLink || null,
      categoryId: category.id,
      subCategoryId: subCategory.id,
      brandId: brand?.id || null,
      brandName: brand?.name || null,
      warrantyType: firstUpload.warrantyType || null,
      warrantyLength: firstUpload.warrantyLength || null,
      createdAt: new Date(),
      updatedAt: new Date(),
      item_details: itemDetails[0],
      item_price: itemPrices[0],
      category: {
        ...category,
        subCategories: [subCategory]
      },
      subCategory,
      brand
    };
    items.push(item);
  }
  console.log("Converted items: ", items);
  return items;
}

function groupByArticleId(uploadData: UploadType[]): Map<string, UploadType[]> {
  console.log("uploadData: ", uploadData);
  const grouped = new Map<string, UploadType[]>();

  for (const upload of uploadData) {
    if (!grouped.has(upload.articleId)) {
      grouped.set(upload.articleId, []);
    }
    grouped.get(upload.articleId)!.push(upload);
  }

  return grouped;
}

async function findOrCreateCategoryAndSubCategory(categoryName: string, subCategoryName: string) {
  // Find or create category
  let category = await prisma.category.findFirst({
    where: { name: categoryName },
    include: { subCategories: true }
  });

  if (!category) {
    category = await prisma.category.create({
      data: {
        name: categoryName,
        slug: generateSlug(categoryName),
        isVisible: true
      },
      include: { subCategories: true }
    });
  }

  // Find or create subcategory
  let subCategory = await prisma.subCategories.findFirst({
    where: {
      name: subCategoryName,
      categoryId: category.id
    }
  });

  if (!subCategory) {
    subCategory = await prisma.subCategories.create({
      data: {
        name: subCategoryName,
        slug: generateSlug(subCategoryName),
        categoryId: category.id,
        isVisible: true
      }
    });
  }

  return { category, subCategory };
}

async function findOrCreateBrand(brandName: string) {
  if (!brandName) return null;

  let brand = await prisma.brand.findFirst({
    where: { name: brandName }
  });

  if (!brand) {
    brand = await prisma.brand.create({
      data: {
        name: brandName,
        alias: generateSlug(brandName),
        imageLink: '', // Default empty, can be updated later
        isVisible: true
      }
    });
  }

  return brand;
}

async function findOrCreateWarehouse(warehouseName: string) {
  let warehouse = await prisma.warehouse.findFirst({
    where: { name: warehouseName }
  });

  if (!warehouse) {
    warehouse = await prisma.warehouse.create({
      data: {
        name: warehouseName,
        displayedName: warehouseName,
        country: null, // Can be updated later
        isVisible: true
      }
    });
  }

  return warehouse;
}

function generateSlug(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function mapBadge(badgeString: string): Badge {
  const badgeMap: Record<string, Badge> = {
    'NEW_ARRIVALS': Badge.NEW_ARRIVALS,
    'BESTSELLER': Badge.BESTSELLER,
    'HOT_DEALS': Badge.HOT_DEALS,
    'LIMITED_EDITION': Badge.LIMITED_EDITION,
    'ABSENT': Badge.ABSENT
  };

  return badgeMap[badgeString?.toUpperCase()] || Badge.ABSENT;
}
