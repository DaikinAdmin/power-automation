import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/db';
import * as schema from '@/db/schema';
import { auth } from '@/lib/auth';
import { eq, and } from 'drizzle-orm';
import { randomUUID } from 'crypto';

interface BulkUploadItem {
  articleId: string;          // Column A
  itemName: string;           // Column D
  slug: string;               // Column F
  brandName?: string;         // Column G
  categoryName?: string;      // Column H
  subCategoryName?: string;   // Column I
  price: number;              // Column J
  isDisplayed?: boolean;      // Column M
  quantity: number;           // Column N
  itemImageLink?: string[];   // Column O
  seller?: string;            // Column P
  description?: string;       // Column Q
  specifications?: string;    // Column R
  metaKeyWords?: string;      // Column U
  metaDescription?: string;   // Column V
  warehouseName: string;      // warehouse.name
  locale: string;             // locale
}

async function ensureAuthorized(request: NextRequest) {
  const session = await auth.api.getSession({
    headers: request.headers,
  });

  if (!session?.user) {
    return { error: NextResponse.json({ error: 'Unauthorized' }, { status: 401 }) };
  }

  const [user] = await db
    .select({ role: schema.user.role })
    .from(schema.user)
    .where(eq(schema.user.id, session.user.id))
    .limit(1);

  if (!user || user.role !== 'admin') {
    return { error: NextResponse.json({ error: 'Forbidden' }, { status: 403 }) };
  }

  return { session };
}

export async function POST(request: NextRequest) {
  try {
    const authResult = await ensureAuthorized(request);
    if ('error' in authResult) {
      return authResult.error;
    }

    const body = await request.json();
    const { items } = body as { items: BulkUploadItem[] };

    if (!items || !Array.isArray(items)) {
      return NextResponse.json(
        { error: 'Invalid request body. Expected items array.' },
        { status: 400 }
      );
    }

    const results = {
      created: 0,
      updated: 0,
      errors: [] as string[],
    };

    const now = new Date().toISOString();

    for (const item of items) {
      try {
        // Validate required fields
        if (!item.articleId || !item.itemName || !item.slug || !item.warehouseName || !item.locale) {
          results.errors.push(
            `Item skipped: missing required fields (articleId, itemName, slug, warehouseName, or locale)`
          );
          continue;
        }

        // Find warehouse by name
        const [warehouse] = await db
          .select()
          .from(schema.warehouse)
          .where(eq(schema.warehouse.name, item.warehouseName))
          .limit(1);

        if (!warehouse) {
          results.errors.push(
            `Item ${item.articleId}: Warehouse '${item.warehouseName}' not found`
          );
          continue;
        }

        // Determine categorySlug
        let categorySlug = '';
        
        if (item.subCategoryName && item.subCategoryName.trim() !== '') {
          // Find subcategory by name
          const [subcategory] = await db
            .select()
            .from(schema.subcategories)
            .where(eq(schema.subcategories.name, item.subCategoryName))
            .limit(1);

          if (subcategory) {
            categorySlug = subcategory.slug;
          } else if (item.categoryName) {
            // Fallback to category if subcategory not found
            const [category] = await db
              .select()
              .from(schema.category)
              .where(eq(schema.category.name, item.categoryName))
              .limit(1);
            
            if (category) {
              categorySlug = category.slug;
            }
          }
        } else if (item.categoryName) {
          // Use category if no subcategory specified
          const [category] = await db
            .select()
            .from(schema.category)
            .where(eq(schema.category.name, item.categoryName))
            .limit(1);
          
          if (category) {
            categorySlug = category.slug;
          }
        }

        // Find brand if specified
        let brandSlug: string | null = null;
        if (item.brandName && item.brandName.trim() !== '') {
          const [brand] = await db
            .select()
            .from(schema.brand)
            .where(eq(schema.brand.name, item.brandName))
            .limit(1);
          
          if (brand) {
            brandSlug = brand.alias;
          }
        }

        // Check if item exists
        const [existingItem] = await db
          .select()
          .from(schema.item)
          .where(eq(schema.item.articleId, item.articleId))
          .limit(1);

        let itemId: string;

        if (existingItem) {
          // UPDATE EXISTING ITEM
          itemId = existingItem.id;

          // Update item record
          await db
            .update(schema.item)
            .set({
              slug: item.slug,
              isDisplayed: item.isDisplayed ?? existingItem.isDisplayed,
              itemImageLink: item.itemImageLink ?? existingItem.itemImageLink,
              categorySlug: categorySlug || existingItem.categorySlug,
              brandSlug: brandSlug ?? existingItem.brandSlug,
              updatedAt: now,
            })
            .where(eq(schema.item.id, itemId));

          // Handle itemDetails
          const [existingDetail] = await db
            .select()
            .from(schema.itemDetails)
            .where(
              and(
                eq(schema.itemDetails.itemSlug, item.slug),
                eq(schema.itemDetails.locale, item.locale)
              )
            )
            .limit(1);

          if (existingDetail) {
            // Update existing itemDetails
            await db
              .update(schema.itemDetails)
              .set({
                itemName: item.itemName,
                description: item.description ?? existingDetail.description,
                specifications: item.specifications ?? existingDetail.specifications,
                seller: item.seller ?? existingDetail.seller,
                metaKeyWords: item.metaKeyWords ?? existingDetail.metaKeyWords,
                metaDescription: item.metaDescription ?? existingDetail.metaDescription,
              })
              .where(eq(schema.itemDetails.id, existingDetail.id));
          } else {
            // Create new itemDetails for this locale
            await db
              .insert(schema.itemDetails)
              .values({
                id: randomUUID(),
                itemSlug: item.slug,
                locale: item.locale,
                itemName: item.itemName,
                description: item.description || '',
                specifications: item.specifications || null,
                seller: item.seller || null,
                metaKeyWords: item.metaKeyWords || null,
                metaDescription: item.metaDescription || null,
              });
          }

          // Handle itemPrice
          const [existingPrice] = await db
            .select()
            .from(schema.itemPrice)
            .where(
              and(
                eq(schema.itemPrice.itemSlug, item.slug),
                eq(schema.itemPrice.warehouseId, warehouse.id)
              )
            )
            .limit(1);

          if (existingPrice) {
            // Create price history record before updating
            await db
              .insert(schema.itemPriceHistory)
              .values({
                id: randomUUID(),
                itemId: itemId,
                warehouseId: warehouse.id,
                price: existingPrice.price,
                quantity: existingPrice.quantity,
                promotionPrice: existingPrice.promotionPrice,
                promoCode: existingPrice.promoCode,
                promoEndDate: existingPrice.promoEndDate,
                badge: existingPrice.badge,
                recordedAt: now,
              });

            // Update existing itemPrice
            await db
              .update(schema.itemPrice)
              .set({
                price: item.price,
                quantity: item.quantity,
                updatedAt: now,
              })
              .where(eq(schema.itemPrice.id, existingPrice.id));
          } else {
            // Create new itemPrice for this warehouse
            await db
              .insert(schema.itemPrice)
              .values({
                id: randomUUID(),
                itemSlug: item.slug,
                warehouseId: warehouse.id,
                price: item.price,
                quantity: item.quantity,
                promotionPrice: null,
                promoCode: null,
                promoEndDate: null,
                badge: 'ABSENT',
                createdAt: now,
                updatedAt: now,
              });
          }

          results.updated++;
        } else {
          // CREATE NEW ITEM
          // Create item record
          const [newItem] = await db
            .insert(schema.item)
            .values({
              articleId: item.articleId,
              slug: item.slug,
              isDisplayed: item.isDisplayed ?? false,
              itemImageLink: item.itemImageLink ?? null,
              categorySlug: categorySlug || '',
              brandSlug: brandSlug,
              updatedAt: now,
            })
            .returning({ id: schema.item.id });

          itemId = newItem.id;

          // Create itemDetails record
          await db
            .insert(schema.itemDetails)
            .values({
              id: randomUUID(),
              itemSlug: item.slug,
              locale: item.locale,
              itemName: item.itemName,
              description: item.description || '',
              specifications: item.specifications || null,
              seller: item.seller || null,
              metaKeyWords: item.metaKeyWords || null,
              metaDescription: item.metaDescription || null,
            });

          // Create itemPrice record
          await db
            .insert(schema.itemPrice)
            .values({
              id: randomUUID(),
              itemSlug: item.slug,
              warehouseId: warehouse.id,
              price: item.price,
              quantity: item.quantity,
              promotionPrice: null,
              promoCode: null,
              promoEndDate: null,
              badge: 'ABSENT',
              createdAt: now,
              updatedAt: now,
            });

          results.created++;
        }
      } catch (itemError) {
        console.error(`Error processing item ${item.articleId}:`, itemError);
        results.errors.push(
          `Item ${item.articleId}: ${itemError instanceof Error ? itemError.message : 'Unknown error'}`
        );
      }
    }

    return NextResponse.json({
      success: true,
      message: `Bulk upload completed. Created: ${results.created}, Updated: ${results.updated}`,
      results,
    });
  } catch (error) {
    console.error('Bulk upload error:', error);
    return NextResponse.json(
      { error: 'Internal server error', message: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
